import click
import logging
from pathlib import Path
import sys
import json
import rdflib # For KCE/EX Namespaces and other RDF operations

# New Layer Imports from kce_core
from kce_core.interfaces import (
    IKnowledgeLayer, IDefinitionTransformationLayer, IPlanner,
    IPlanExecutor, INodeExecutor, IRuleEngine, IRuntimeStateLogger,
    TargetDescription, RDFGraph, ExecutionResult, LoadStatus # Key data structures
)
from kce_core.knowledge_layer.rdf_store.store_manager import RdfStoreManager
from kce_core.definition_transformation_layer.loader import DefinitionLoader
from kce_core.execution_layer.node_executor import NodeExecutor
from kce_core.execution_layer.runtime_state_logger import RuntimeStateLogger
from kce_core.execution_layer.plan_executor import PlanExecutor
from kce_core.planning_reasoning_core_layer.rule_engine import RuleEngine
from kce_core.planning_reasoning_core_layer.planner import Planner

# Common utilities - ensure these are available and correct in common.utils
# from kce_core.common.utils import load_json_file, to_uriref # Placeholder, actual functions might differ
from kce_core.common.utils import generate_instance_uri # Example, if needed directly

# Logger Setup (basic example, adapt if you have a central logger in utils)
kce_logger = logging.getLogger("kce_cli")
if not kce_logger.handlers: # Avoid duplicate handlers
    cli_handler = logging.StreamHandler(sys.stdout)
    # Basic formatter, can be made more sophisticated
    cli_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    cli_handler.setFormatter(cli_formatter)
    kce_logger.addHandler(cli_handler)
    kce_logger.setLevel(logging.INFO) # Default level, can be changed by -v option

# Custom Exception Classes (define here or import from a common kce_core.errors module)
class KCEError(Exception):
    """Base class for KCE specific errors."""
    pass

class DefinitionError(KCEError):
    """Error related to parsing or validity of KCE definitions."""
    pass

class RDFStoreError(KCEError):
    """Error related to RDF store operations."""
    pass

class ExecutionError(KCEError):
    """Error related to the execution of nodes or plans."""
    pass

class ConfigurationError(KCEError):
    """Error related to system configuration."""
    pass


# Version and Namespaces
def get_kce_version():
    # In future, this might read from a version file or git tag
    return "0.3.0-refactored"

KCE = rdflib.Namespace("http://kce.com/ontology/core#")
EX = rdflib.Namespace("http://example.com/ns#") # General example namespace
# Define other common RDF namespaces if used directly in CLI logic (e.g. for constructing URIs)
RDF = rdflib.RDF
RDFS = rdflib.RDFS
OWL = rdflib.OWL
XSD = rdflib.XSD
DCTERMS = rdflib.DCTERMS # Example, if needed
PROV = rdflib.PROV # Example, if needed


# --- CLI Configuration Constants (defined at module level) ---
DEFAULT_DB_PATH = "kce_store.sqlite" # Default SQLite DB file name
# Assuming this script (cli/main.py) is in 'cli_project_root/cli/main.py'
# Then project root is Path(__file__).resolve().parent.parent
PROJECT_ROOT_DIR = Path(__file__).resolve().parent.parent
DEFAULT_ONTOLOGY_DIR = PROJECT_ROOT_DIR / "ontologies"
DEFAULT_EXAMPLES_DIR = PROJECT_ROOT_DIR / "examples" # If needed for defaults

# Ensure namespaces used in KCE are available if kce_core.common.utils doesn't re-export them all
# This is just to be safe, ideally they come from one place like common.utils or kce_core.__init__
kce_common_ns = {
    "KCE": KCE, "EX": EX, "RDF": RDF, "RDFS": RDFS, "OWL": OWL, "XSD": XSD,
    "DCTERMS": DCTERMS, "PROV": PROV
}
