import yaml
import json
import os
from pathlib import Path # Added Path
import uuid # Added for generating fallback URIs
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib.namespace import RDF, RDFS, XSD

# Assuming interfaces.py is two levels up from definition_transformation_layer directory
from ..interfaces import IDefinitionTransformationLayer, IKnowledgeLayer, LoadStatus, InitialStateGraph, DirectoryPath
# Assuming common.exceptions for KCEError, DefinitionError
from ..common.exceptions import KCEError, DefinitionError

# Define KCE and other relevant namespaces (should ideally come from a central ontology definitions file)
KCE = Namespace("http://kce.com/ontology/core#")
EX = Namespace("http://example.com/ns#") # Example namespace for instance data
DOMAIN = Namespace("http://kce.com/example/elevator_panel#") # For example domain

class DefinitionLoader(IDefinitionTransformationLayer):
    def __init__(self, knowledge_layer: IKnowledgeLayer):
        self.kl = knowledge_layer
        self.kce_ns_map = {
            "kce": KCE,
            "rdf": RDF,
            "rdfs": RDFS,
            "xsd": XSD,
            "ex": EX,
            "domain": DOMAIN
        }

    def _prefix_uri(self, value: str) -> URIRef:
        if ":" in value:
            prefix, local_name = value.split(":", 1)
            if prefix in self.kce_ns_map:
                return self.kce_ns_map[prefix][local_name]
        if value.startswith("http://") or value.startswith("https://") or value.startswith("urn:"):
            return URIRef(value)
        # print(f"Warning: No prefix found for '{value}', defaulting to EX namespace: {EX[value]}") # Uncomment for debugging
        return EX[value] # Fallback, consider if this should be stricter

    def _parse_node_definition(self, data: Dict, file_path_str: str) -> Graph: # file_path_str is absolute path to YAML
        g = Graph()
        node_uri_str = data.get("uri")
        if not node_uri_str:
            node_uri_str = f"urn:uuid:{uuid.uuid4()}"
            print(f"Warning (DefinitionLoader): Node definition in {file_path_str} missing 'uri'. Generated: {node_uri_str}")
        node_uri = self._prefix_uri(node_uri_str)

        g.add((node_uri, RDF.type, KCE.AtomicNode))

        if "name" in data: g.add((node_uri, RDFS.label, Literal(data["name"])))
        if "description" in data: g.add((node_uri, RDFS.comment, Literal(data["description"])))

        if "precondition" in data: g.add((node_uri, KCE.hasPrecondition, Literal(data["precondition"], datatype=KCE.SparqlQuery)))
        if "effect" in data: g.add((node_uri, KCE.hasEffect, Literal(data["effect"], datatype=KCE.SparqlUpdateTemplate)))

        for param_type_key, kce_predicate, param_rdf_type in [("inputs", KCE.hasInputParameter, KCE.InputParameter),
                                                       ("outputs", KCE.hasOutputParameter, KCE.OutputParameter)]:
            if param_type_key in data:
                for p_data in data[param_type_key]:
                    param_name = p_data.get("name")
                    if not param_name: continue
                    param_uri_str = p_data.get("uri", f"{node_uri_str}/param/{param_name}")
                    param_uri = self._prefix_uri(param_uri_str)

                    g.add((param_uri, RDF.type, param_rdf_type))
                    g.add((param_uri, RDFS.label, Literal(param_name)))
                    if "mapsToRdfProperty" in p_data: g.add((param_uri, KCE.mapsToRdfProperty, self._prefix_uri(p_data["mapsToRdfProperty"])))
                    if "datatype" in p_data: g.add((param_uri, KCE.hasDatatype, self._prefix_uri(p_data["datatype"])))
                    if "isRequired" in p_data and param_type_key == "inputs":
                        g.add((param_uri, KCE.isRequired, Literal(p_data["isRequired"], datatype=XSD.boolean)))
                    g.add((node_uri, kce_predicate, param_uri))

        if "implementation" in data:
            impl_data = data["implementation"]
            impl_uri_str = f"{node_uri_str}/implementation"
            impl_uri = self._prefix_uri(impl_uri_str)
            g.add((impl_uri, RDF.type, KCE.ImplementationDetail))

            impl_type_str = impl_data.get("type")
            if impl_type_str: g.add((impl_uri, KCE.invocationType, self._prefix_uri(impl_type_str)))

            if "scriptPath" in impl_data:
                original_script_path = impl_data["scriptPath"]
                yaml_file_path_obj = Path(file_path_str)
                yaml_dir = yaml_file_path_obj.parent
                resolved_script_path = (yaml_dir / original_script_path).resolve()
                g.add((impl_uri, KCE.scriptPath, Literal(str(resolved_script_path))))
                if not resolved_script_path.is_file():
                    print(f"Warning (DefinitionLoader): Script at resolved path {resolved_script_path} (from '{original_script_path}' in {file_path_str}) was not found. NodeExecutor will perform final check.")

            g.add((node_uri, KCE.hasImplementationDetail, impl_uri))

        for prefix, namespace_obj in self.kce_ns_map.items(): g.bind(prefix, namespace_obj)
        return g

    def _parse_rule_definition(self, data: Dict, file_path_str: str) -> Graph:
        g = Graph()
        rule_uri_str = data.get("uri")
        if not rule_uri_str: rule_uri_str = f"urn:uuid:{uuid.uuid4()}"
        rule_uri = self._prefix_uri(rule_uri_str)
        g.add((rule_uri, RDF.type, KCE.Rule))
        if "name" in data: g.add((rule_uri, RDFS.label, Literal(data["name"])))
        if "description" in data: g.add((rule_uri, RDFS.comment, Literal(data["description"])))
        if "priority" in data: g.add((rule_uri, KCE.hasPriority, Literal(data["priority"], datatype=XSD.integer)))
        if "antecedent" in data: g.add((rule_uri, KCE.hasAntecedent, Literal(data["antecedent"], datatype=KCE.SparqlQuery)))
        if "consequent" in data: g.add((rule_uri, KCE.hasConsequent, Literal(data["consequent"], datatype=KCE.SparqlUpdateTemplate))) # Assuming update, can be refined
        for prefix, namespace_obj in self.kce_ns_map.items(): g.bind(prefix, namespace_obj)
        return g

    def _parse_capability_template_definition(self, data: Dict, file_path_str: str) -> Graph:
        g = Graph()
        print(f"Warning (DefinitionLoader): CapabilityTemplate parsing not fully implemented. Skipping item in {file_path_str}")
        return g

    def load_definitions_from_path(self, definitions_dir_path: DirectoryPath) -> LoadStatus:
        loaded_docs_count = 0
        errors = []
        abs_definitions_dir_path = Path(definitions_dir_path).resolve()

        for root, _, files in os.walk(abs_definitions_dir_path):
            for file_name in files:
                if file_name.endswith(('.yaml', '.yml')):
                    abs_file_path_str = str(Path(root) / file_name)
                    try:
                        with open(abs_file_path_str, 'r', encoding='utf-8') as f:
                            yaml_documents = list(yaml.safe_load_all(f))

                        for doc_data in yaml_documents:
                            if not doc_data or not isinstance(doc_data, dict): continue

                            doc_kind = doc_data.get("kind")
                            rdf_graph = None

                            if doc_kind == "AtomicNode":
                                rdf_graph = self._parse_node_definition(doc_data, abs_file_path_str)
                            elif doc_kind == "Rule":
                                rdf_graph = self._parse_rule_definition(doc_data, abs_file_path_str)
                            elif doc_kind == "CapabilityTemplate":
                                rdf_graph = self._parse_capability_template_definition(doc_data, abs_file_path_str)
                            else:
                                errors.append({"file": abs_file_path_str, "error": f"Unknown 'kind': {doc_kind} (keys: {list(doc_data.keys())})"})
                                continue

                            if rdf_graph and len(rdf_graph) > 0:
                                self.kl.add_graph(rdf_graph)
                                loaded_docs_count += 1

                    except yaml.YAMLError as ye:
                        errors.append({"file": abs_file_path_str, "error": f"YAML parsing error: {ye}"})
                    except Exception as e:
                        errors.append({"file": abs_file_path_str, "error": f"General error processing file: {e}"})

        return {"loaded_definitions_count": loaded_docs_count, "errors": errors}

    def load_initial_state_from_json(self, json_data_str: str, base_uri: str) -> InitialStateGraph:
        from ..common.utils import create_rdf_graph_from_json_ld_dict
        try:
            data = json.loads(json_data_str)
            return create_rdf_graph_from_json_ld_dict(data, default_base_ns_str=base_uri)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON for initial state: {e}")
            raise DefinitionError(f"Invalid JSON for initial state: {e}") from e
        except Exception as e:
            print(f"Error converting initial state JSON to RDF: {e}")
            raise KCEError(f"Could not convert JSON to RDF: {e}") from e
