@cli.command("solve-problem") # Renamed from run-workflow
@click.option('--target-desc-file', type=click.Path(exists=True, dir_okay=False, resolve_path=True), required=True,
              help="Path to a JSON file describing the target goal (e.g., a SPARQL ASK query).")
@click.option('--initial-state-file', type=click.Path(exists=True, dir_okay=False, resolve_path=True), required=True,
              help="Path to a JSON file describing the initial state of the problem.")
@click.option('--run-id', 'custom_run_id', type=str, default=None, # Renamed variable to avoid clash
              help="Assign a specific run ID. If not provided, one will be generated.")
@click.option('--mode', type=click.Choice(['user', 'expert'], case_sensitive=False), default='user',
              help="Execution mode (user: fully-auto, expert: allows intervention - MVP simplified).")
@pass_cli_context
def solve_problem(ctx: CliContext, target_desc_file: str, initial_state_file: str, custom_run_id: Optional[str], mode: str):
    """Solves a problem defined by a target and an initial state using the KCE Planner."""
    if not all([ctx.planner, ctx.knowledge_layer, ctx.plan_executor, ctx.rule_engine, ctx.definition_loader, ctx.runtime_logger]):
        # Added ctx.runtime_logger to the check
        kce_logger.error("Core KCE components not initialized. Cannot solve problem. Check arguments or run init-db and load-defs.")
        click.echo("Error: Core KCE components not initialized. Check arguments or run init-db and load-defs.", err=True)
        sys.exit(1)

    import uuid # For generating run_id if not provided
    current_run_id = custom_run_id if custom_run_id else f"run_{uuid.uuid4()}"
    click.echo(f"Attempting to solve problem. Run ID: {current_run_id}")
    kce_logger.info(f"Starting solve-problem for Run ID: {current_run_id}")

    try:
        # 1. Load target description from file
        # Assuming load_json_file is available. If not, basic json.load will be used.
        try:
            from kce_core.common.utils import load_json_file # Attempt to import
            target_desc_data = load_json_file(target_desc_file)
        except ImportError:
            kce_logger.warning("kce_core.common.utils.load_json_file not found. Using basic json.load.")
            with open(target_desc_file, 'r', encoding='utf-8') as f_target:
                target_desc_data = json.load(f_target)

        if not isinstance(target_desc_data, dict) or not target_desc_data.get("sparql_ask_query"):
            err_msg_target = (f"Target description file '{target_desc_file}' must be a JSON object " + \
                             "containing at least a 'sparql_ask_query' field for the MVP planner.")
            kce_logger.error(err_msg_target)
            raise DefinitionError(err_msg_target)
        target_description: TargetDescription = target_desc_data # Type hint
        kce_logger.info(f"Loaded target description from: {target_desc_file}")

        # 2. Load initial state JSON and convert to RDF graph
        with open(initial_state_file, 'r', encoding='utf-8') as f_initial:
            initial_state_json_str = f_initial.read()

        instance_base_uri = f"http://example.com/instances/{current_run_id}/problem_data/"

        initial_state_rdf_graph: RDFGraph = ctx.definition_loader.load_initial_state_from_json(
            json_data_str=initial_state_json_str,
            base_uri=instance_base_uri
        )
        click.echo(f"Loaded initial state from '{initial_state_file}' ({len(initial_state_rdf_graph)} triples generated).")
        kce_logger.info(f"Loaded initial state from '{initial_state_file}', {len(initial_state_rdf_graph)} triples generated.")

        # 3. Call Planner.solve
        click.echo(f"Invoking KCE Planner for target defined in '{target_desc_file}'...")
        kce_logger.info(f"Invoking Planner.solve for Run ID: {current_run_id}")

        # Type hints for components passed to planner.solve to satisfy mypy if ctx attributes are Optional
        # The check at the beginning of the function ensures these are not None.
        planner_instance: IPlanner = ctx.planner # type: ignore
        kl_instance: IKnowledgeLayer = ctx.knowledge_layer # type: ignore
        pe_instance: IPlanExecutor = ctx.plan_executor # type: ignore
        re_instance: IRuleEngine = ctx.rule_engine # type: ignore

        execution_result: ExecutionResult = planner_instance.solve(
            target_description=target_description,
            initial_state_graph=initial_state_rdf_graph,
            knowledge_layer=kl_instance,
            plan_executor=pe_instance,
            rule_engine=re_instance,
            run_id=current_run_id,
            mode=mode
        )

        # 4. Process and display result
        if execution_result.get("status") == "success":
            success_final_msg = f"Problem solving successful for Run ID: {current_run_id}"
            click.echo(click.style(success_final_msg, fg="green"))
            kce_logger.info(success_final_msg)
            click.echo(f"Message: {execution_result.get('message', 'Completed.')}")
            if ctx.verbose and "plan_executed" in execution_result:
                executed_plan = execution_result["plan_executed"]
                if isinstance(executed_plan, list) and executed_plan:
                    click.echo("Executed plan steps:")
                    for i, step in enumerate(executed_plan):
                        if isinstance(step, dict):
                             click.echo(f"  {i+1}. Type: {step.get('operation_type', 'N/A')}, URI: <{step.get('operation_uri', 'N/A')}>")
                        else:
                             click.echo(f"  {i+1}. (Malformed step: {step})")
                elif executed_plan: # If it's not a list but present
                    click.echo(f"Executed plan (summary): {executed_plan}")
                else:
                    click.echo("No detailed plan steps available in result or plan was empty.")
        else:
            failure_final_msg = f"Problem solving failed for Run ID: {current_run_id}"
            click.echo(click.style(failure_final_msg, fg="red"), err=True)
            kce_logger.error(failure_final_msg)
            click.echo(f"Message: {execution_result.get('message', 'No specific error message provided.')}", err=True)
            sys.exit(1) # Exit with error code for script automation

    except DefinitionError as e:
        err_msg = f"Definition error for run_id {current_run_id}: {e}"
        kce_logger.error(err_msg, exc_info=ctx.verbose)
        click.echo(click.style(f"Definition Error: {e}", fg="red"), err=True); sys.exit(1)
    except KCEError as e:
        err_msg = f"KCE error during problem solving for run_id {current_run_id}: {e}"
        kce_logger.error(err_msg, exc_info=ctx.verbose)
        click.echo(click.style(f"Error: {e}", fg="red"), err=True); sys.exit(1)
    except FileNotFoundError as e:
        err_msg = f"File not found for run_id {current_run_id}: {e}"
        kce_logger.error(err_msg, exc_info=ctx.verbose)
        click.echo(click.style(f"File Not Found Error: {e}", fg="red"), err=True); sys.exit(1)
    except json.JSONDecodeError as e:
        err_msg = f"Invalid JSON in input file for run_id {current_run_id}: {e}"
        kce_logger.error(err_msg, exc_info=ctx.verbose)
        click.echo(click.style(f"JSON Decode Error: {e}", fg="red"), err=True); sys.exit(1)
    except Exception as e:
        err_msg = f"Unexpected error during problem solving for run_id {current_run_id}: {e}"
        kce_logger.critical(err_msg, exc_info=True) # Use critical for unexpected
        click.echo(click.style(f"Unexpected Error: {e}", fg="red"), err=True); sys.exit(1)
