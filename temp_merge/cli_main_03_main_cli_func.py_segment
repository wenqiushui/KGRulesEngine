# --- Main CLI Group ---
@click.group(context_settings=dict(help_option_names=['-h', '--help']))
@click.option('--db-path', default=None, type=click.Path(),
              help=f"Path to the KCE SQLite database file. Default: '{DEFAULT_DB_PATH}' in current dir if not in-memory.")
@click.option('--in-memory', is_flag=True, default=False,
              help="Use an in-memory RDF store (overrides --db-path if set).")
@click.option('--base-script-path', default=None, type=click.Path(exists=True, file_okay=False, dir_okay=True, resolve_path=True),
              help="Base directory for resolving relative script paths in definitions (used by NodeExecutor).")
@click.option('-v', '--verbose', is_flag=True, help="Enable verbose logging (DEBUG level).")
@click.version_option(version=get_kce_version(), prog_name="KCE CLI Refactored")
@pass_cli_context
def cli(ctx: CliContext, db_path: Optional[str], in_memory: bool, base_script_path: Optional[str], verbose: bool):
    """Knowledge-CAD-Engine (KCE) Command Line Interface - Refactored"""

    # Logger and path setup
    ctx.verbose = verbose
    if verbose:
        kce_logger.setLevel(logging.DEBUG)
        for handler in kce_logger.handlers: handler.setLevel(logging.DEBUG)
        kce_logger.debug("Verbose logging enabled.")
    else:
        kce_logger.setLevel(logging.INFO)
        for handler in kce_logger.handlers: handler.setLevel(logging.INFO)

    actual_db_path: Optional[str] = None
    if in_memory:
        kce_logger.info("Using in-memory RDF store.")
    elif db_path:
        actual_db_path = db_path
    else:
        actual_db_path = str(PROJECT_ROOT_DIR / DEFAULT_DB_PATH) # Use PROJECT_ROOT_DIR from segment 1

    # Store Path object or None in context
    ctx.db_path = Path(actual_db_path) if actual_db_path else None

    if base_script_path:
        ctx.base_script_path = Path(base_script_path)
        kce_logger.info(f"NodeExecutor will use base script path: {ctx.base_script_path}")
    else:
        # Default base_script_path to PROJECT_ROOT_DIR/examples/scripts if available, or PROJECT_ROOT_DIR/scripts, or just PROJECT_ROOT_DIR
        # This helps NodeExecutor find scripts if not explicitly set.
        # The NodeExecutor itself has a search strategy, this sets a primary default for it.
        candidate_script_bases = [
            PROJECT_ROOT_DIR / "examples" / "scripts", # if examples dir exists
            PROJECT_ROOT_DIR / "scripts" # if a general scripts dir exists at root
        ]
        for cand_path in candidate_script_bases:
            if cand_path.exists() and cand_path.is_dir():
                ctx.base_script_path = cand_path
                kce_logger.info(f"NodeExecutor using auto-detected base script path: {ctx.base_script_path}")
                break
        if not ctx.base_script_path:
            ctx.base_script_path = PROJECT_ROOT_DIR # Fallback to project root
            kce_logger.info(f"NodeExecutor base script path defaulted to project root: {ctx.base_script_path}")

    # New component initialization logic
    try:
        # DEFAULT_ONTOLOGY_DIR should be defined in segment 1
        core_ontology_path = str(DEFAULT_ONTOLOGY_DIR / "kce_core_ontology.ttl")
        ont_files_to_load = []
        if Path(core_ontology_path).exists():
            ont_files_to_load.append(core_ontology_path)
        else:
             kce_logger.warning(f"Core KCE ontology file not found at {core_ontology_path}. Store might be missing core schema definitions.")

        # 1. Knowledge Layer
        ctx.knowledge_layer = RdfStoreManager(db_path=actual_db_path, ontology_files=ont_files_to_load)

        # 2. Definition Transformation Layer
        ctx.definition_loader = DefinitionLoader(knowledge_layer=ctx.knowledge_layer)

        # 3. RuntimeStateLogger (no direct KCE layer deps in constructor)
        ctx.runtime_logger = RuntimeStateLogger()

        # 4. NodeExecutor
        # NodeExecutor might be enhanced to take base_script_path in its constructor.
        # For now, it uses its internal logic which can be influenced by CWD or env vars.
        # If NodeExecutor is changed: # ctx.node_executor = NodeExecutor(base_script_path=ctx.base_script_path)
        ctx.node_executor = NodeExecutor() # Assuming NodeExecutor has its own script path resolution logic for now

        # 5. RuleEngine (needs RuntimeStateLogger)
        ctx.rule_engine = RuleEngine(runtime_state_logger=ctx.runtime_logger)

        # 6. PlanExecutor (needs NodeExecutor, RuntimeStateLogger, RuleEngine)
        ctx.plan_executor = PlanExecutor(
            node_executor=ctx.node_executor,
            runtime_state_logger=ctx.runtime_logger,
            rule_engine=ctx.rule_engine
        )

        # 7. Planner (needs RuntimeStateLogger in constructor)
        ctx.planner = Planner(runtime_state_logger=ctx.runtime_logger)

        kce_logger.info(f"KCE CLI initialized successfully. Store: {actual_db_path or 'in-memory'}.")

    except KCEError as e: # KCEError should be defined in segment 1
        kce_logger.error(f"Failed to initialize KCE components: {e}", exc_info=ctx.verbose)
        click.echo(f"Error: Failed to initialize KCE components: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        kce_logger.error(f"Unexpected error during KCE initialization: {e}", exc_info=True)
        click.echo(f"Unexpected Error during initialization: {e}", err=True)
        sys.exit(1)
